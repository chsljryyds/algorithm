# leetcode ---- 岛屿问题





给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。





解法：

```python
def num_islands(grid):
    if not grid:
        return 0

    def dfs(grid, i, j):
        # 如果越界或当前格子为水，则返回
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
            return
        
        # 将当前格子标记为水，以避免重复访问
        grid[i][j] = '0'
        
        # 递归地访问相邻的四个方向
        dfs(grid, i + 1, j)  # 下
        dfs(grid, i - 1, j)  # 上
        dfs(grid, i, j + 1)  # 右
        dfs(grid, i, j - 1)  # 左

    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == '1':
                # 遇到新的岛屿，进行 DFS，将整个岛屿标记
                dfs(grid, i, j)
                count += 1  # 每调用一次 DFS，就找到一个新的岛屿
    
    return count

```



### 详细解释

1. **初始化和边界检查**：

```python
if not grid:
    return 0
```

- 如果网格为空，直接返回 0。

1. **DFS 函数定义**：

```python
def dfs(grid, i, j):
    # 如果越界或当前格子为水，则返回
    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':
        return

    # 将当前格子标记为水，以避免重复访问
    grid[i][j] = '0'
    
    # 递归地访问相邻的四个方向
    dfs(grid, i + 1, j)  # 下
    dfs(grid, i - 1, j)  # 上
    dfs(grid, i, j + 1)  # 右
    dfs(grid, i, j - 1)  # 左
```

- 递归地访问当前节点的上下左右相邻节点。如果相邻节点是陆地（'1'），则标记为水（'0'）并继续递归。

1. **遍历网格并调用 DFS**：

```python
count = 0
for i in range(len(grid)):
    for j in range(len(grid[0])):
        if grid[i][j] == '1':
            # 遇到新的岛屿，进行 DFS，将整个岛屿标记
            dfs(grid, i, j)
            count += 1  # 每调用一次 DFS，就找到一个新的岛屿
```

- 遍历网格的每个单元格。如果遇到陆地（'1'），调用 DFS 并增加岛屿计数。

### 示例执行过程

我们使用以下示例网格来详细说明算法的执行过程：

```python
grid = [
    ["1","1","0","0","0"],
    ["1","1","0","0","0"],
    ["0","0","1","0","0"],
    ["0","0","0","1","1"]
]
```

#### 初始状态

- `count = 0`
- 遍历到 `grid[0][0]`（'1'），调用 DFS。

#### 第一次 DFS 调用（从 `grid[0][0]` 开始）

1. 标记 `grid[0][0]` 为 '0'。
2. 递归调用 `dfs(grid, 1, 0)`（向下）。
3. 标记 `grid[1][0]` 为 '0'。
4. 递归调用 `dfs(grid, 2, 0)`（向下，越界，返回）。
5. 递归调用 `dfs(grid, 0, 0)`（向上，已标记为 '0'，返回）。
6. 递归调用 `dfs(grid, 1, 1)`（向右）。
7. 标记 `grid[1][1]` 为 '0'。
8. 递归调用 `dfs(grid, 2, 1)`（向下，越界，返回）。
9. 递归调用 `dfs(grid, 0, 1)`（向上）。
10. 标记 `grid[0][1]` 为 '0'。
11. 递归调用 `dfs(grid, 1, 1)`（向下，已标记为 '0'，返回）。
12. 递归调用 `dfs(grid, -1, 1)`（向上，越界，返回）。
13. 递归调用 `dfs(grid, 0, 2)`（向右，水，返回）。
14. 递归调用 `dfs(grid, 0, 0)`（向左，已标记为 '0'，返回）。

#### 第一次 DFS 结束

- `count = 1`

#### 第二次 DFS 调用（从 `grid[2][2]` 开始）

- 遍历到 `grid[2][2]`（'1'），调用 DFS。

1. 标记 `grid[2][2]` 为 '0'。
2. 递归调用 `dfs(grid, 3, 2)`（向下，水，返回）。
3. 递归调用 `dfs(grid, 1, 2)`（向上，水，返回）。
4. 递归调用 `dfs(grid, 2, 3)`（向右，水，返回）。
5. 递归调用 `dfs(grid, 2, 1)`（向左，已标记为 '0'，返回）。

#### 第二次 DFS 结束

- `count = 2`

#### 第三次 DFS 调用（从 `grid[3][3]` 开始）

- 遍历到 `grid[3][3]`（'1'），调用 DFS。

1. 标记 `grid[3][3]` 为 '0'。
2. 递归调用 `dfs(grid, 4, 3)`（向下，越界，返回）。
3. 递归调用 `dfs(grid, 2, 3)`（向上，水，返回）。
4. 递归调用 `dfs(grid, 3, 4)`（向右）。
5. 标记 `grid[3][4]` 为 '0'。
6. 递归调用 `dfs(grid, 4, 4)`（向下，越界，返回）。
7. 递归调用 `dfs(grid, 2, 4)`（向上，水，返回）。
8. 递归调用 `dfs(grid, 3, 5)`（向右，越界，返回）。
9. 递归调用 `dfs(grid, 3, 3)`（向左，已标记为 '0'，返回）。

#### 第三次 DFS 结束

- `count = 3`

#### 遍历结束

- 最终返回岛屿计数 `count = 3`。

### 总结

DFS 算法通过递归地访问每个相邻的陆地单元格，将整个岛屿标记为水，从而避免重复计算同一个岛屿。这个过程确保我们准确地统计了网格中的岛屿数量。





### 递归算法：

好的，我来详细讲解递归算法。递归是一种算法设计技巧，在这种技巧中，函数通过直接或间接调用自身来解决问题。递归通常用于解决那些可以被分解为更小的子问题的任务。递归函数在调用自身时会创建一个新的函数执行环境，每个环境都有自己的局部变量和参数。理解递归的关键是理解递归的两个基本组成部分：基例和递归步骤。

### 递归的两个基本组成部分

1. 基例（Base Case）

   ：

   - 基例是递归函数不再递归调用自身的条件，即终止条件。当递归达到基例时，函数将返回一个结果而不是调用自身。

2. 递归步骤（Recursive Step）

   ：

   - 递归步骤是函数通过调用自身来解决问题的部分。在每个递归步骤中，问题的规模应该逐渐缩小，最终达到基例。

### 递归算法示例：计算阶乘

阶乘（Factorial）是一个经典的递归问题。定义为：n! = n * (n-1) * (n-2) * ... * 1，其中 0! = 1。

#### 递归计算阶乘的 Python 代码

```python
def factorial(n):
    # 基例：0 的阶乘是 1
    if n == 0:
        return 1
    else:
        # 递归步骤：n 的阶乘是 n 乘以 (n-1) 的阶乘
        return n * factorial(n - 1)

```

### 递归过程详细解释

以计算 `factorial(5)` 为例：

1. 调用 `factorial(5)`：
   - 因为 5 != 0，所以执行 `5 * factorial(4)`。
2. 调用 `factorial(4)`：
   - 因为 4 != 0，所以执行 `4 * factorial(3)`。
3. 调用 `factorial(3)`：
   - 因为 3 != 0，所以执行 `3 * factorial(2)`。
4. 调用 `factorial(2)`：
   - 因为 2 != 0，所以执行 `2 * factorial(1)`。
5. 调用 `factorial(1)`：
   - 因为 1 != 0，所以执行 `1 * factorial(0)`。
6. 调用 `factorial(0)`：
   - 因为 0 == 0，所以返回 1（基例）。

从这里开始，函数开始返回结果：

1. `factorial(1)` 返回 `1 * 1 = 1`
2. `factorial(2)` 返回 `2 * 1 = 2`
3. `factorial(3)` 返回 `3 * 2 = 6`
4. `factorial(4)` 返回 `4 * 6 = 24`
5. `factorial(5)` 返回 `5 * 24 = 120`

最终，`factorial(5)` 的结果是 120。