# leetcode ---- 55-----跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

 

解法：

```python
def canJump(nums):
    max_jump = 0  # 初始化最远可达距离
    for i in range(len(nums)):
        if i > max_jump:
            return False  # 如果当前位置超过了最远可达距离，则无法到达
        max_jump = max(max_jump, i + nums[i])  # 更新最远可达距离
        if max_jump >= len(nums) - 1:
            return True  # 如果最远可达距离已经超过或者到达数组最后一个位置，则返回True
    return False

```





这道题是经典的跳跃游戏问题，我们需要判断是否能够从数组的第一个位置跳到最后一个位置。每个数组元素表示在当前位置可以跳跃的最大长度。

我们可以使用贪心算法来解决这个问题，思路如下：

1. **初始化跳跃范围：** 用一个变量 `max_jump` 记录当前能够达到的最远位置，初始时为0，因为我们从第一个位置开始。
2. **遍历数组：** 遍历数组中的每个元素，同时更新 `max_jump` 的值，以确保我们始终记录当前能够到达的最远位置。
3. **更新 `max_jump`：** 对于当前位置 `i`，更新 `max_jump` 的方法是取当前 `max_jump` 和 `i + nums[i]` 中的较大值，这表示从当前位置能够跳到的最远位置。
4. **判断是否能到达最后位置：** 在遍历过程中，如果 `max_jump` 大于或等于数组的最后一个位置 `len(nums) - 1`，则说明可以到达最后一个位置，返回 `True`。
5. **遍历结束仍未能到达：** 如果遍历完数组后 `max_jump` 仍未大于或等于 `len(nums) - 1`，则返回 `False`。



**解释代码逻辑：**

- 我们使用一个循环遍历数组 `nums`，在每个位置 `i` 更新 `max_jump` 的值。
- 如果在某个位置 `i`，`i > max_jump`，说明当前位置无法到达，直接返回 `False`。
- 更新 `max_jump` 为 `max(max_jump, i + nums[i])`，保持当前能够达到的最远位置。
- 如果 `max_jump` 大于等于 `len(nums) - 1`，则返回 `True`，否则遍历完数组返回 `False`。

这种方法的时间复杂度为 `O(n)`，其中 `n` 是数组的长度，因为我们只需一次遍历数组并进行常数时间的操作来更新 `max_jump`