# leetcode ------ 寻找两个正序数组的中位数



给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```



`解法：

```python
def findMedianSortedArrays(nums1, nums2):
    # 确保 nums1 是较短的数组
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2
    
    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i
        if i < m and nums1[i] < nums2[j-1]:
            # i 太小，必须增大它
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            # i 太大，必须减小它
            imax = i - 1
        else:
            # i 是完美的
            if i == 0: max_of_left = nums2[j-1]
            elif j == 0: max_of_left = nums1[i-1]
            else: max_of_left = max(nums1[i-1], nums2[j-1])
            
            if (m + n) % 2 == 1:
                return max_of_left
            
            if i == m: min_of_right = nums2[j]
            elif j == n: min_of_right = nums1[i]
            else: min_of_right = min(nums1[i], nums2[j])
            
            return (max_of_left + min_of_right) / 2.0

# 测试用例
nums1 = [1, 3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2))  # 输出 2.0

nums1 = [1, 2]
nums2 = [3, 4]
print(findMedianSortedArrays(nums1, nums2))  # 输出 2.5

```



要在两个正序数组中找到中位数，并且时间复杂度要求为 O(log(m + n))，可以使用一种称为“二分查找”的方法来解决问题。具体来说，我们可以通过在较小的数组上进行二分查找来找到中位数。以下是详细的步骤：

### 步骤 1：理解中位数的定义

如果两个数组的总长度是奇数，中位数就是第 (m+n)//2+1(m+n)//2 + 1(m+n)//2+1 个元素。如果总长度是偶数，中位数就是第 (m+n)//2(m+n)//2(m+n)//2 和第 (m+n)//2+1(m+n)//2 + 1(m+n)//2+1 个元素的平均值。

### 步骤 2：合并数组

假设我们已经合并了两个数组 nums1 和 nums2，合并后的数组是一个长度为 m + n 的有序数组，那么我们需要找到第 (m + n) // 2 和第 (m + n) // 2 + 1 个元素。

### 步骤 3：使用二分查找

我们可以在较短的数组 nums1 上进行二分查找，尝试找到一个切割点，使得左边部分和右边部分分别来自两个数组，且满足中位数的要求。具体步骤如下：

1. 定义两个数组 nums1 和 nums2，确保 nums1 是较短的那个数组。如果 nums1 比 nums2 长，则交换它们。
2. 设定变量 imin 和 imax，分别表示 nums1 的最小和最大索引。
3. 进行二分查找：
   - 计算 nums1 和 nums2 的中间索引 i 和 j，其中 i=(imin+imax)//2i = (imin + imax) // 2i=(imin+imax)//2，j=(m+n+1)//2−ij = (m + n + 1) // 2 - ij=(m+n+1)//2−i。
   - 检查 i 和 j 是否满足条件：
     - 如果 nums1[i-1] <= nums2[j] 且 nums2[j-1] <= nums1[i]，则找到了合适的切割点。
     - 否则调整 imin 或 imax 以继续二分查找。
4. 根据切割点的条件找到中位数。







好的，下面我将通过具体的例子 `nums1 = [1, 2]` 和 `nums2 = [3, 4]` 来详细解释每个步骤的实现过程。

### 初始条件

- `nums1 = [1, 2]`
- `nums2 = [3, 4]`

首先，确保 `nums1` 是较短的数组，如果不是，则交换它们。但在这个例子中，`nums1` 本来就较短。

### 初始化变量

```
m, n = len(nums1), len(nums2)  # m = 2, n = 2
imin, imax, half_len = 0, m, (m + n + 1) // 2  # imin = 0, imax = 2, half_len = 2
```

### 第一次迭代

```
i = (imin + imax) // 2  # i = (0 + 2) // 2 = 1
j = half_len - i  # j = 2 - 1 = 1
```

检查条件：

```
if i < m and nums1[i] < nums2[j-1]:  # nums1[1] < nums2[0] -> 2 < 3 是True
    imin = i + 1  # imin = 1 + 1 = 2
elif i > 0 and nums1[i-1] > nums2[j]:  # 这个条件不执行
    imax = i - 1
else:
    # 这个条件不执行
```

### 第二次迭代

```
python复制代码i = (imin + imax) // 2  # i = (2 + 2) // 2 = 2
j = half_len - i  # j = 2 - 2 = 0
```

检查条件：

```
if i < m and nums1[i] < nums2[j-1]:  # 这个条件不执行，因为 i == m
    imin = i + 1
elif i > 0 and nums1[i-1] > nums2[j]:  # nums1[1] > nums2[0] -> 2 > 3 是False
    imax = i - 1
else:
    # 这个条件执行，表示找到了合适的 i 和 j
```

### 找到合适的切割点

由于找到了合适的切割点，我们现在需要计算左半部分的最大值和右半部分的最小值。

```
if i == 0: 
    max_of_left = nums2[j-1]  # 这个条件不执行，因为 i != 0
elif j == 0: 
    max_of_left = nums1[i-1]  # j == 0，所以 max_of_left = nums1[1] = 2
else: 
    max_of_left = max(nums1[i-1], nums2[j-1])  # 这个条件不执行
```

接下来检查数组长度的奇偶性：

```
if (m + n) % 2 == 1:  # (2 + 2) % 2 == 1 是False
    return max_of_left
```

如果总长度是偶数，则中位数是左半部分的最大值和右半部分的最小值的平均值：

```
if i == m: 
    min_of_right = nums2[j]  # i == m，所以 min_of_right = nums2[0] = 3
elif j == n: 
    min_of_right = nums1[i]  # 这个条件不执行
else: 
    min_of_right = min(nums1[i], nums2[j])  # 这个条件不执行
```

最终计算中位数：

```

return (max_of_left + min_of_right) / 2.0  # (2 + 3) / 2.0 = 2.5
```

### 结果

中位数是 2.5。

### 总结

通过这个例子，我们演示了如何通过二分查找的方法在两个有序数组中找到中位数。主要步骤是：

1. 确保使用较短的数组进行二分查找。
2. 通过调整 `imin` 和 `imax` 找到合适的切割点，使得左半部分和右半部分满足中位数的定义。
3. 计算并返回中位数。







j=(m+n+1)//2−i。为什么j等于这个呢



ChatGPT：

这是因为我们在尝试将两个数组分成左右两部分，使得每部分包含的元素数量相等或近似相等。以下是详细的解释：

### 理解切割的概念

假设我们将两个数组 `nums1` 和 `nums2` 进行切割，使得左半部分和右半部分分别包含一些元素。这种切割需要满足两个条件：

1. 左半部分和右半部分的元素数量要尽量相等。
2. 左半部分的最大值小于等于右半部分的最小值。

### 切割后的数组

设 `i` 是数组 `nums1` 中的切割点，`j` 是数组 `nums2` 中的切割点。我们希望左半部分和右半部分包含的元素数量分别为 `(m + n + 1) // 2`。所以有：

- 左半部分的元素：`nums1` 的前 `i` 个元素加上 `nums2` 的前 `j` 个元素。
- 右半部分的元素：`nums1` 的后 `m - i` 个元素加上 `nums2` 的后 `n - j` 个元素。

### 确定 j 的值

为了让左半部分和右半部分的元素数量尽量相等，我们可以通过以下方式确定 `j` 的值：

```

j = (m + n + 1) // 2 - i
```

这个公式的含义是：我们希望左半部分的总元素数量为 `(m + n + 1) // 2`，其中 `i` 是 `nums1` 的左半部分元素数量，那么 `j` 就是 `nums2` 的左半部分元素数量。

### 为什么要加 1

加 1 的原因是为了处理总长度为奇数的情况。例如，如果总长度是 5，那么左半部分应有 3 个元素，右半部分应有 2 个元素。加 1 可以确保切割时左半部分元素数量大于或等于右半部分的元素数量。

### 例子

假设 `nums1 = [1, 2]`，`nums2 = [3, 4]`，总长度 `m + n = 4`：

1. `half_len = (m + n + 1) // 2 = (2 + 2 + 1) // 2 = 2`
2. 初始 `i = (imin + imax) // 2 = (0 + 2) // 2 = 1`
3. 计算 `j = half_len - i = 2 - 1 = 1`

这样，我们得到 `i = 1` 和 `j = 1`，分别将 `nums1` 和 `nums2` 切割成两部分。

### 总结

`j = (m + n + 1) // 2 - i` 的公式确保了在两个数组中切割后，左半部分的元素数量总是等于或多于右半部分的元素数量，从而便于我们找到两个数组的中位数。通过二分查找调整 `i`，我们可以高效地找到满足条件的切割点，使得左半部分的最大值小于等于右半部分的最小值。





好的，让我们详细解释 `i` 和 `j` 作为切割点在数组中的具体位置以及它们的含义。通过这个解释，你将理解为什么要这样选择 `i` 和 `j`。

### 总体思路

目标是将两个有序数组 `nums1` 和 `nums2` 切割成两部分，使得左半部分和右半部分的元素数量尽量相等。特别地：

- 左半部分的元素数量应该等于 `(m + n + 1) // 2`。
- 右半部分的元素数量应该是剩下的元素数量。

### 定义切割点

设 `i` 是 `nums1` 中的切割点，`j` 是 `nums2` 中的切割点。我们希望满足以下条件：

1. 左半部分的元素数量等于 `(m + n + 1) // 2`。
2. 左半部分的最大值小于等于右半部分的最小值。

### 公式推导

为了确保左半部分的元素数量正确，我们有：

```

j = (m + n + 1) // 2 - i
```

这个公式的含义是：如果我们在 `nums1` 中选择了 `i` 个元素，那么在 `nums2` 中需要选择 `j` 个元素，使得左半部分的总元素数量等于 `(m + n + 1) // 2`。

### 举例说明

假设有两个数组：

- `nums1 = [1, 2]`
- `nums2 = [3, 4]`

总长度 `m + n = 4`，因此我们要找到使得左半部分和右半部分数量相等的切割点。

1. `half_len = (m + n + 1) // 2 = (2 + 2 + 1) // 2 = 2`

#### 切割点的选择和条件检查

**第一次迭代：**

- `imin = 0, imax = 2`
- `i = (imin + imax) // 2 = (0 + 2) // 2 = 1`
- `j = half_len - i = 2 - 1 = 1`

这意味着我们将 `nums1` 切割成 `[1]` 和 `[2]`，将 `nums2` 切割成 `[3]` 和 `[4]`。

切割结果为：

- 左半部分：`[1] + [3]`
- 右半部分：`[2] + [4]`

检查条件：

```
if i < m and nums1[i] < nums2[j-1]:  # nums1[1] < nums2[0] -> 2 < 3 是True
    imin = i + 1  # imin = 1 + 1 = 2
elif i > 0 and nums1[i-1] > nums2[j]:  # 这个条件不执行
    imax = i - 1
else:
    # 这个条件不执行
```

**第二次迭代：**

- `i = (imin + imax) // 2 = (2 + 2) // 2 = 2`
- `j = half_len - i = 2 - 2 = 0`

这意味着我们将 `nums1` 切割成 `[1, 2]` 和 `[]`，将 `nums2` 切割成 `[]` 和 `[3, 4]`。

切割结果为：

- 左半部分：`[1, 2] + []`
- 右半部分：`[] + [3, 4]`

检查条件：

```
if i < m and nums1[i] < nums2[j-1]:  # 这个条件不执行，因为 i == m
elif i > 0 and nums1[i-1] > nums2[j]:  # 这个条件不执行
else:
    # 这个条件执行，表示找到了合适的 i 和 j
```

### 计算中位数

因为 `i == m`，所以右半部分的最小值是 `nums2[j]`：

```

min_of_right = nums2[j] = nums2[0] = 3
```

左半部分的最大值是 `nums1[i-1]`：

```

max_of_left = nums1[i-1] = nums1[1] = 2
```

因为总长度是偶数，所以中位数是左半部分最大值和右半部分最小值的平均值：

```

median = (max_of_left + min_of_right) / 2 = (2 + 3) / 2 = 2.5
```

### 总结

`i` 和 `j` 分别作为 `nums1` 和 `nums2` 的切割点，其含义是将两个数组切割成两部分，使得左半部分和右半部分的元素数量尽量相等。通过二分查找调整 `i`，我们可以高效地找到满足条件的切割点，使得左半部分的最大值小于等于右半部分的最小值，从而准确计算中位数。





### t提问

if i < m and nums1[i] < nums2[j-1]:    imin = i + 1 elif i > 0 and nums1[i-1] > nums2[j]:    imax = i - 1 能再详细讲解一下这段代码吗，nums1[i]和nums2[j-1],nums1[i-1],nums2[j]都分别代表什么位置呢



ChatGPT

这段代码是用于在二分查找过程中调整 `i` 的搜索范围，以便找到满足条件的切割点 `i` 和 `j`。让我们详细解释每一行的含义，并理解其中涉及的数组索引位置：

```
if i < m and nums1[i] < nums2[j-1]:
    imin = i + 1
```

- `i < m`：这个条件确保 `i` 在有效的 `nums1` 数组索引范围内。因为 `i` 是 `nums1` 的索引，所以 `i` 必须小于 `m`，即 `i` 应该小于 `nums1` 的长度。
- `nums1[i]`：表示 `nums1` 数组中的第 `i` 个元素。在二分查找的过程中，`i` 是我们正在考虑的切割点。
- `nums2[j-1]`：表示 `nums2` 数组中的第 `j-1` 个元素。在二分查找中，`j` 是根据 `i` 计算得出的，用于将 `nums2` 切割成左右两部分。
- `nums1[i] < nums2[j-1]`：这个条件检查当前选择的 `i` 是否满足要求，即 `nums1` 的右半部分的最小值（即 `nums1[i]`）必须小于 `nums2` 的左半部分的最大值（即 `nums2[j-1]`）。
- `imin = i + 1`：如果条件成立，将 `imin` 更新为 `i + 1`，从而在 `nums1` 的右半部分继续寻找更大的 `i`。

```
elif i > 0 and nums1[i-1] > nums2[j]:
    imax = i - 1
```

- `i > 0`：这个条件确保 `i` 大于 `0`，即 `nums1` 的索引不能是负数。
- `nums1[i-1]`：表示 `nums1` 数组中的第 `i-1` 个元素。在二分查找的过程中，`i-1` 是我们考虑的另一个可能的切割点。
- `nums2[j]`：表示 `nums2` 数组中的第 `j` 个元素。在二分查找中，`j` 是根据 `i` 计算得出的，用于将 `nums2` 切割成左右两部分。
- `nums1[i-1] > nums2[j]`：这个条件检查当前选择的 `i-1` 是否满足要求，即 `nums1` 的左半部分的最大值（即 `nums1[i-1]`）必须大于 `nums2` 的右半部分的最小值（即 `nums2[j]`）。
- `imax = i - 1`：如果条件成立，将 `imax` 更新为 `i - 1`，从而在 `nums1` 的左半部分继续寻找更小的 `i`。

### 数组索引的含义总结

- `nums1[i]`：表示 `nums1` 数组中的第 `i` 个元素，即当前考虑的切割点 `i` 的值。
- `nums2[j-1]`：表示 `nums2` 数组中的第 `j-1` 个元素，即 `nums2` 中左半部分的最大值。
- `nums1[i-1]`：表示 `nums1` 数组中的第 `i-1` 个元素，即考虑 `i` 之前的一个可能的切割点。
- `nums2[j]`：表示 `nums2` 数组中的第 `j` 个元素，即 `nums2` 中右半部分的最小值。

在二分查找过程中，这些数组索引的合理使用确保了我们能够在 `nums1` 和 `nums2` 中找到满足条件的切割点 `i` 和 `j`，从而正确地划分左右两部分，并计算中位数或其他需要的值。