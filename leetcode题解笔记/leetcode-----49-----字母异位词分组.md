## leetcode-----49-----字母异位词分组



给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。





解法：解决这个问题的核心思想是识别字母异位词的本质：两个字母异位词排序后会得到相同的字符串。因此，我们可以利用这个特性，将所有字母异位词组合在一起。

### 解题思路

1. **定义字母异位词**：字母异位词是由重新排列源单词的所有字母得到的一个新单词。因此，对于任何两个字母异位词，将它们的字符排序后会得到相同的字符串。
2. **使用哈希表（字典）**：我们可以使用一个哈希表（字典）来将排序后的字符串作为键，把所有属于该键的字符串存储在对应的值（列表）中。
3. **遍历字符串数组**：对于每个字符串，将其字符排序，然后将排序后的字符串作为键，将原字符串添加到该键对应的值（列表）中。
4. **返回结果**：遍历完所有字符串后，哈希表中的每个值（列表）就是一组字母异位词。我们只需要返回这些值即可。

### 具体步骤

1. 初始化一个空的字典 `anagrams`。

2. 遍历每个字符串 

   ```
   s
   ```

   ：

   - 将字符串 `s` 的字符排序，得到 `sorted_s`。
   - 如果 `sorted_s` 作为键不存在于 `anagrams` 中，则将 `sorted_s` 初始化为空列表。
   - 将原字符串 `s` 添加到 `sorted_s` 对应的列表中。

3. 最后，将字典 `anagrams` 中的所有值（列表）提取出来，作为结果返回。

### Python 实现

下面是该算法的 Python 实现：





```python

def group_anagrams(strs):
    anagrams = {}
    
    for s in strs:
        # 将字符串的字符排序
        sorted_s = ''.join(sorted(s))
        
        # 将排序后的字符串作为键，原字符串添加到该键对应的列表中
        if sorted_s not in anagrams:
            anagrams[sorted_s] = []
        anagrams[sorted_s].append(s)
    
    # 提取字典中的所有值（列表）
    return list(anagrams.values())

# 测试
strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
print(group_anagrams(strs))

```

### 解释代码

1. **初始化字典**：`anagrams` 用于存储排序后的字符串及其对应的字母异位词列表。
2. **遍历字符串数组**：对于每个字符串 `s`，将其字符排序，得到 `sorted_s`。
3. **更新字典**：检查 `sorted_s` 是否在字典 `anagrams` 中。如果不在，则创建一个新的键值对。如果在，则将原字符串 `s` 添加到对应的列表中。
4. **返回结果**：字典 `anagrams` 中的每个值（列表）就是一组字母异位词，最后返回这些值。

### 复杂度分析

- **时间复杂度**：排序每个字符串的时间复杂度是 O(klog⁡k)O(k \log k)O(klogk)，其中 kkk 是字符串的平均长度。遍历所有字符串的时间复杂度是 O(n)O(n)O(n)，其中 nnn 是字符串数组的长度。因此，总的时间复杂度是 O(n⋅klog⁡k)O(n \cdot k \log k)O(n⋅klogk)。
- **空间复杂度**：需要额外的空间来存储排序后的字符串和字典中的列表。因此，空间复杂度是 O(n⋅k)O(n \cdot k)O(n⋅k)，用于存储所有字符串。

这样，我们可以高效地将字母异位词组合在一起，并返回结果列表。



### 初始状态

我们有一个空字典 `anagrams = {}`。

### 迭代过程

我们逐个处理列表中的字符串：

1. **处理字符串 "eat"**:
   - 排序 "eat" 得到 "aet"。
   - 检查字典中是否有键 "aet"：没有，因此创建一个新键值对 `"aet": ["eat"]`。
   - 现在字典是 `{"aet": ["eat"]}`。
2. **处理字符串 "tea"**:
   - 排序 "tea" 得到 "aet"。
   - 检查字典中是否有键 "aet"：有，因此在对应列表中添加 "tea"。
   - 现在字典是 `{"aet": ["eat", "tea"]}`。
3. **处理字符串 "tan"**:
   - 排序 "tan" 得到 "ant"。
   - 检查字典中是否有键 "ant"：没有，因此创建一个新键值对 `"ant": ["tan"]`。
   - 现在字典是 `{"aet": ["eat", "tea"], "ant": ["tan"]}`。
4. **处理字符串 "ate"**:
   - 排序 "ate" 得到 "aet"。
   - 检查字典中是否有键 "aet"：有，因此在对应列表中添加 "ate"。
   - 现在字典是 `{"aet": ["eat", "tea", "ate"], "ant": ["tan"]}`。
5. **处理字符串 "nat"**:
   - 排序 "nat" 得到 "ant"。
   - 检查字典中是否有键 "ant"：有，因此在对应列表中添加 "nat"。
   - 现在字典是 `{"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"]}`。
6. **处理字符串 "bat"**:
   - 排序 "bat" 得到 "abt"。
   - 检查字典中是否有键 "abt"：没有，因此创建一个新键值对 `"abt": ["bat"]`。
   - 现在字典是 `{"aet": ["eat", "tea", "ate"], "ant": ["tan", "nat"], "abt": ["bat"]}`。

### 最终结果

最后，我们将字典中的所有值（列表）提取出来，作为结果返回：

```python
result = list(anagrams.values())
# 结果是 [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]

```

