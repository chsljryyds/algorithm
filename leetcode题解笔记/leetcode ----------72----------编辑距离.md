# leetcode ----------72----------编辑距离

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

 

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```





解法：

```python
def minDistance(word1: str, word2: str) -> int:
    m, n = len(word1), len(word2)
    
    # Initialize dp table
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Initialize base cases
    for i in range(1, m + 1):
        dp[i][0] = i
    for j in range(1, n + 1):
        dp[0][j] = j
    
    # Fill dp table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = min(dp[i][j - 1] + 1,  # Insert
                               dp[i - 1][j] + 1,  # Delete
                               dp[i - 1][j - 1] + 1)  # Replace
    
    return dp[m][n]

```



![83d914155ac51fe68417d043221da13](C:\Users\果果\Desktop\83d914155ac51fe68417d043221da13.png)

这道题是经典的编辑距离（Edit Distance）问题，可以使用动态规划（Dynamic Programming）来解决。编辑距离指的是将一个字符串转换成另一个字符串所需的最少操作次数，操作包括插入一个字符、删除一个字符、替换一个字符。

### 动态规划解法详解：

1. **定义状态：** 设 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符编辑成 `word2` 的前 `j` 个字符所需的最小操作数。

2. **状态转移：**

   - 如果 `word1[i-1] == word2[j-1]`，即当前字符相同，那么 `dp[i][j] = dp[i-1][j-1]`，不需要额外操作。

   - 如果 

     ```
     word1[i-1] != word2[j-1]
     ```

     ，即当前字符不同，可以进行以下三种操作：

     - 插入操作：`dp[i][j] = dp[i][j-1] + 1`
     - 删除操作：`dp[i][j] = dp[i-1][j] + 1`
     - 替换操作：`dp[i][j] = dp[i-1][j-1] + 1` 最终 `dp[i][j]` 取上述三种操作中的最小值。

3. **初始化：**

   - `dp[0][0]` 表示将空字符串转换成空字符串，操作数为 `0`。
   - `dp[i][0]` 表示将 `word1` 的前 `i` 个字符转换成空字符串，操作数为 `i`（即删除操作）。
   - `dp[0][j]` 表示将空字符串转换成 `word2` 的前 `j` 个字符，操作数为 `j`（即插入操作）。

4. **边界条件：**

   - `dp[0][0] = 0`
   - `dp[i][0] = i` 对于所有 `i`
   - `dp[0][j] = j` 对于所有 `j`

5. **计算顺序：** 根据定义的状态转移方程和初始化条件，可以逐步计算 `dp[i][j]` 直到 `dp[len(word1)][len(word2)]`，即 `word1` 的全部字符转换成 `word2` 的全部字符的最小操作数。









### 3. 动态规划解决编辑距离问题的步骤

**步骤分解如下：**

**a. 定义状态：** 设 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符编辑成 `word2` 的前 `j` 个字符所需的最小操作数。

**b. 初始化状态：**

- `dp[0][0] = 0`：空字符串到空字符串的编辑距离为 0。
- `dp[i][0] = i`：空字符串到 `word1` 的前 `i` 个字符的编辑距离为 `i`（即全部删除操作）。
- `dp[0][j] = j`：空字符串到 `word2` 的前 `j` 个字符的编辑距离为 `j`（即全部插入操作）。

**c. 状态转移：** 根据字符是否相同，可以进行以下操作：

- 如果 `word1[i-1] == word2[j-1]`，即当前字符相同，则 `dp[i][j] = dp[i-1][j-1]`，不需要额外操作。

- 如果 

  ```
  word1[i-1] != word2[j-1]
  ```

  ，即当前字符不同，则可以考虑三种操作：

  - 插入操作：`dp[i][j] = dp[i][j-1] + 1`
  - 删除操作：`dp[i][j] = dp[i-1][j] + 1`
  - 替换操作：`dp[i][j] = dp[i-1][j-1] + 1`

  选择上述三种操作中的最小值作为 

  ```
  dp[i][j]
  ```

   的值。

**d. 计算顺序：** 从 `dp[0][0]` 开始，依次计算到 `dp[len(word1)][len(word2)]`，直到得到最终的编辑距离。









dp = [[0] * (n + 1) for _ in range(m + 1)] 这里面为什么要n+1和m+1呢？



ChatGPT

在动态规划解决编辑距离问题时，通常会使用一个二维数组 `dp` 来存储中间状态。让我们来详细解释为什么要使用 `n + 1` 和 `m + 1`。

### 1. 状态定义和数组索引

假设有两个字符串 `word1` 和 `word2`，它们的长度分别为 `m` 和 `n`。

- `m = len(word1)`
- `n = len(word2)`

我们定义 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符所需的最小操作数。在动态规划中，通常使用一个二维数组来存储这些状态，即 `dp[i][j]`。

### 2. 数组初始化

为了处理边界情况和方便计算，我们通常将 `dp` 数组的大小设为 `(m + 1) x (n + 1)`。

- `dp[i][0]` 表示将 `word1` 的前 `i` 个字符转换为一个空字符串（长度为 `0` 的 `word2`），需要删除 `i` 个字符。
- `dp[0][j]` 表示将一个空字符串转换为 `word2` 的前 `j` 个字符，需要插入 `j` 个字符。

因此，我们需要数组长度为 `m + 1` 和 `n + 1`，以便包括这些特殊情况。

### 3. 索引解释

- `dp[0][0]` 到 `dp[m][n]` 分别对应于将 `word1` 的不同前缀转换为 `word2` 的不同前缀的最小操作数。
- `dp[i][j]` 的含义是明确的：它表示了将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符的最小操作数。









ok  插入操作：dp[i][j] = dp[i][j-1] + 1 那么插入操作  为什么需要j-1呢？



ChatGPT

在动态规划解法中，编辑距离问题中的插入操作 `dp[i][j] = dp[i][j-1] + 1` 是这样定义的：

1. **插入操作的定义：** 当我们在 `word1` 的第 `i` 个位置之后插入 `word2` 的第 `j` 个字符时，实际上相当于将 `word2` 的前 `j-1` 个字符转换为 `word1` 的前 `i` 个字符，然后在 `word1[i-1]` 后面插入 `word2[j-1]`。因此，插入操作的操作数 `dp[i][j]` 等于将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j-1` 个字符所需的最小操作数 `dp[i][j-1]`，再加上插入操作本身的成本（+1）。
2. **理解 `j-1` 的原因：**
   - 当我们考虑在 `word1` 的第 `i` 个位置后插入 `word2` 的第 `j` 个字符时，我们实际上在 `word1` 的前 `i` 个字符基础上，增加了一个字符，这个字符就是 `word2[j-1]`。因此，插入操作要考虑将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j-1` 个字符的最小操作数，然后再进行一次插入操作。
3. **示例：**
   - 假设 `word1 = "horse"`，`word2 = "ros"`。
   - 当 `i = 4`（即考虑将 "horse" 的前 4 个字符转换为 "ros"）和 `j = 3`（即考虑将 "ros" 的前 3 个字符）时，插入操作 `dp[4][3]` 就是将 "horse" 转换为 "ro" 的最小操作数 `dp[4][2]`，再加上一个插入操作（+1）。

综上所述，插入操作 `dp[i][j] = dp[i][j-1] + 1` 中的 `j-1` 是因为我们在计算 `dp[i][j]` 时，是基于 `dp[i][j-1]` 的结果再进行一次插入操作。