# 455------分发饼干------leetcode

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 

```python
def findContentChildren(g, s):
    g.sort()  # 排序孩子的胃口值
    s.sort()  # 排序饼干的尺寸
    
    child = 0  # 孩子的指针
    cookie = 0  # 饼干的指针
    
    while child < len(g) and cookie < len(s):
        if s[cookie] >= g[child]:
            # 如果当前饼干能满足当前孩子的胃口
            child += 1  # 满足孩子，孩子指针向后移动
        cookie += 1  # 不管能不能满足，饼干指针都向后移动
    
    return child  # 返回能被满足的孩子数量

# 示例
g = [1, 2, 3]
s = [1, 1]
print(findContentChildren(g, s))  # 输出：1

```

这道题目是经典的贪心算法问题，也是《算法导论》中经常提到的一种类型——优先满足最容易满足的孩子，以最大化满足的孩子数量。

### 解题思路

1. **问题理解**：
   - 每个孩子有一个胃口值 `g[i]`，表示他能接受的最小饼干尺寸。
   - 每块饼干有一个尺寸 `s[j]`。
   - 要最大化满足的孩子数量，即尽可能多的孩子能收到满足胃口的饼干。
2. **贪心策略**：
   - 对孩子的胃口值 `g` 和饼干的尺寸 `s` 分别进行排序。
   - 从胃口值最小的孩子开始，尝试用最小的饼干去满足他，然后依次向后满足其他孩子。
3. **实现步骤**：
   - 首先对 `g` 和 `s` 进行排序。
   - 使用两个指针分别指向孩子的胃口数组 `g` 和饼干的尺寸数组 `s`。
   - 如果当前饼干能满足当前孩子的胃口，就将这块饼干分配给孩子，并将两个指针都向后移动；否则只移动饼干尺寸指针，寻找更大的饼干。
   - 继续这个过程直到任意一个数组遍历完毕。





### 解释代码：

- `findContentChildren` 函数接受两个数组 `g` 和 `s`，分别表示孩子的胃口值和饼干的尺寸。
- 使用 `sort()` 方法对 `g` 和 `s` 进行排序，保证从最小值开始满足。
- 使用 `child` 和 `cookie` 两个指针分别遍历 `g` 和 `s`，通过比较饼干尺寸是否满足孩子的胃口来决定是否满足孩子。
- 最终返回能够被满足的孩子数量 `child`。

这种贪心算法的时间复杂度主要取决于排序的时间复杂度，为 O(nlog⁡n)O(n \log n)O(nlogn)，其中 `n` 是孩子的数量或者饼干的数量，因此是非常高效的解法。





