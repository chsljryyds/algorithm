# leetcode-------169--------多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。



解法：

```python
def majorityElement(nums):
    candidate = None
    count = 0
    
    for num in nums:
        if count == 0:
            candidate = num
            count = 1
        elif num == candidate:
            count += 1
        else:
            count -= 1
    
    return candidate

```



当我们要找出数组中的多数元素（即出现次数超过数组长度一半的元素），可以利用Boyer-Moore投票算法（Boyer-Moore Voting Algorithm）。这种方法非常高效，只需要O(n)的时间复杂度和O(1)的空间复杂度。

### Boyer-Moore投票算法详解

算法的基本思想是通过不断消除不同的元素，最终剩下的元素就有可能是多数元素。具体步骤如下：

1. **初始化候选元素**：假设第一个元素是候选元素 `candidate`，初始计数 `count` 设为1。

2. **遍历数组**：从第二个元素开始遍历数组。

   - 如果当前元素与 `candidate` 相同，则计数 `count` 加1。

   - 如果当前元素与 

     ```
     candidate
     ```

      不同，则计数 

     ```
     count
     ```

      减1。

     - 如果 `count` 减到0，意味着当前 `candidate` 不是多数元素，重新选择下一个元素作为候选元素，并将计数 `count` 重置为1。

3. **返回候选元素**：由于题目保证一定存在多数元素，最终留下的 `candidate` 就是多数元素。

这个算法的正确性基于以下两个事实：

- 如果存在多数元素，它一定能在遍历过程中被保留下来。
- 最后留下的元素即使不是多数元素，也不影响最终的正确性，因为该算法的设计保证了如果存在多数元素，最终返回的一定是多数元素。





### 示例

假设输入数组为 `[3, 2, 3]`，按照算法的步骤：

- 初始化 `candidate = 3`，`count = 1`。
- 遍历到第二个元素 `2`，`count` 减为0，更新 `candidate = 2`，`count = 1`。
- 遍历到最后一个元素 `3`，`count` 又加回1，所以最终的 `candidate` 为 `3`，即数组中的多数元素。

这样，通过简单的遍历一次数组，就能找到多数元素，并且算法的时间复杂度为 O(n)，空间复杂度为 O(1)，非常高效。