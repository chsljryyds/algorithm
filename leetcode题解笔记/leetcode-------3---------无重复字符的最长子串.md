# leetcode-------3---------无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长** 

**子串**

 的长度。



 

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



解法:

```python
def lengthOfLongestSubstring(s):
    n = len(s)
    if n == 0:
        return 0
    
    max_len = 0
    left = 0
    seen = set()
    
    for right in range(n):
        while s[right] in seen:
            seen.remove(s[left])
            left += 1
        seen.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len

```



这道题要求找出给定字符串中最长的不含重复字符的子串的长度。我们可以通过使用滑动窗口（双指针）的方法来解决这个问题。

### 解题思路

1. **定义指针和变量**：
   - 使用两个指针 `left` 和 `right` 表示滑动窗口的左右边界。
   - 使用一个集合 `seen` 来存储当前窗口中的字符，以便快速判断字符是否重复。
2. **滑动窗口操作**：
   - 初始时，`left` 指向字符串的开头，`right` 指向字符串的第一个字符。
   - 遍历字符串，每次将 `right` 指向的字符加入到 `seen` 集合中。
   - 如果 `seen` 中已经存在 `s[right]`，则说明当前窗口中有重复字符，需要移动 `left` 指针直到窗口中不再有重复字符为止。
   - 每次移动 `right` 指针时，更新最长子串的长度（即 `right - left + 1`）。
3. **更新最大长度**：
   - 每次移动 `right` 指针时，都更新最大长度，直到遍历完整个字符串。
4. **返回结果**：
   - 最终得到的最大长度即为所求的结果。









### 解释代码：

- `n = len(s)` 获取字符串 `s` 的长度。
- 如果字符串长度为0，直接返回0。
- `max_len` 用于记录最长不重复子串的长度。
- `left` 是窗口的左边界，初始化为0。
- `seen` 是一个集合，用来存储当前窗口中出现过的字符。

在 `for right in range(n)` 的循环中：

- 将 `s[right]` 加入 `seen` 集合中。
- 如果 `s[right]` 已经在 `seen` 中，表示窗口中有重复字符，需要将 `left` 指针右移，直到窗口中不再有重复字符。
- 每次移动 `right` 指针时，更新 `max_len` 的值为当前窗口的长度（`right - left + 1`）和 `max_len` 之间的较大值。

最终返回 `max_len` 即为最长不重复子串的长度。

这种方法的时间复杂度是 O(n)，其中 n 是字符串的长度，因为每个字符最多被访问两次（一次是加入 `seen` 集合，一次是从 `seen` 集合中移除），所以是线性的时间复杂度。